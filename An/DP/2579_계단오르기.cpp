//왜!!
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <algorithm>

using namespace std;

int FALE()
{
	int n, a[301] = { 0, }, d[301] = { 0, }, check[301] = {0,};
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", a + i);
	d[1] = a[1];
	d[2] = a[1] + a[2]; check[2] = 1;
	if (a[1] <= a[2])  //이게 문제가 된거같다.
	{
		d[3] = a[2] + a[3];
		check[3] = 1;
	}
	

	for (int i = 4; i <= n; i++)
	{
		if (d[i - 2] >= d[i - 1]) 
		{
			d[i] = d[i - 2] + a[i];
			check[i] = 0;
		}
		else 
		{
			if (check[i - 1] == 1) 
			{
				d[i] = d[i - 2] + a[i];
				check[i] = 0;
			}
			else 
			{
				d[i] = d[i - 1] + a[i];
				check[i] = 1;
			}
		}
	}
	printf("%d", d[n]);
	system("pause");
}

int main()
{
	int n, a[301] = { 0, }, d[301] = { 0, };
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", a + i);
	d[1] = a[1];
	d[2] = a[1] + a[2];

	for (int i = 3; i <= n; i++) 
	{
		d[i] = max(d[i - 3] + a[i] + a[i - 1], d[i - 2] + a[i]);
	}
	printf("%d", d[n]);
}


/*
계단오르기 시간복잡도 n^3 ~ n^4
포도주 문제랑 비슷한듯.
조건 : 연속해서 2개이상 불가능, 꼭대기 까지 올라가야함.

d[n] : a[n]을 마지막으로 하는 점수 최대값

올라가는 방법은 두개로 나뉜다.
한개올라가는 경우: d[n] = d[n-1] + a[n]
두개 올라가는 경우: d[n] = d[n-2] + a[n]

먼저 두경우중 값이 큰값으로 선택.
두개 올라가는경우가 크면 무리없이 그걸로
한개로 올라가는 경우가 크면 이게 연속이였는지 확인.
연속이면 두개 올라가는 경우로
이렇게 하면 n=3에서 123으로 항상 첫계단 밟음
그래서 d[3]을 초기로 주고 했는데도 안댐 
테스트케이스는 정답. 모르겠다 ㅠㅠ

강의 : 
체크 그런거 없이 
d정의를 가지고 조건에따라 점화식 세움
d[i]는 i번째 계단에 올라갔을때 최대 점수
1개연속으로 올라가는경우 :
d[i] = d[i-2] + a[i] (이전이 어떻게 올라오든 상관없음)
2개연속으로 올라가는 경우:
(이전이 i-1에서 연속으로 올라오는 경우로 생각하여
 check변수에 두려했으나 이상해짐 -> 이렇게 check 변수를 사용해야겠다
 생각하는 문제는 check하지말고 1차원 변수로 풀고  점화식세울때 
 문제 조건을 녹이기 )
 d[i] = d[i-3] + a[i-1] + a[i]
 이렇게 세움으로써 i-3에서 어떻게 끝나든 점프해서 가니깐 상관없음


*/